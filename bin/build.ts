#!/usr/bin/env node

const path = require('path');
const nodeCrypto = require('crypto');
const { rmSync, readFileSync, readdirSync, existsSync, writeFileSync } = require('fs');
const paramsDocs = require('./params-docs');
const paramsBase64 = require('./params-base64');

type Webpack = typeof import('webpack');

type Configuration = Parameters<Webpack>[0][number];

(async function () {
  // @ts-ignore
  const { default: webpack } = (await import('webpack')) as unknown as {
    default: Webpack;
  };
  // @ts-ignore
  const { default: chalk } = await import('chalk');

  if (!process.argv[2]) {
    throw new Error(chalk.red("Main filename can't be undefined"));
  }

  const DIST_DIR = path.resolve(process.cwd(), 'dist');
  const filename = path.resolve('.', process.argv[2]);

  if (process.argv.includes('--clean')) {
    try {
      rmSync(DIST_DIR, { recursive: true, force: true });
    } catch {
      //
    }
  }

  const V7 = process.argv.includes('--v7');

  /**
   * Readme file path can be defined as:
   * --readme <path-to-readme.md>
   * --readme=<path-to-readme.md>
   *
   * If not defined, the default readme file will be used.
   * The default readme file is the README.md file in the root of the project.
   */
  const readmeFile = process.argv.find(
    (arg) => arg.startsWith('--readme=') || arg.startsWith('--readme '),
  );
  let readmeContent = '';

  if (readmeFile) {
    const readmePath = readmeFile.split('=')[1] || readmeFile.split(' ')[1];

    if (existsSync(readmePath)) {
      readmeContent = readFileSync(readmePath, {
        encoding: 'utf-8',
        flag: 'r',
      });
    } else {
      throw new Error(chalk.red(`Readme file not found: ${readmePath}`));
    }
  }

  const helperPackage = require(
    path.resolve(__dirname, '..', '..', 'package.json'),
  );

  const packageFile: {
    [p: string]: any;
  } = require(path.resolve(process.cwd(), 'package.json'));
  const packageDir = readdirSync(process.cwd(), {
    encoding: 'utf-8',
    flag: 'r',
  });

  const presetEnv = V7
    ? {
        useBuiltIns: 'entry',
        corejs: '3.8',
        targets: {
          chrome: 97, // January 2022 - supports async/await
        },
        modules: false,
      }
    : {
        targets: 'ie 11',
      };

  // Analyze parseParams usage in the source file
  const paramsDescription = paramsDocs.analyzeParseParams(filename);
  const paramsData = paramsDocs.analyzeParseParamsData(filename);

  const paramsBase64String = paramsBase64.generateParamsBase64(paramsData);

  // Hash of main file and all imported files (deterministic for same sources)
  const sourceFiles = paramsDocs.getSourceFilesFromEntry(filename);
  const hasher = nodeCrypto.createHash('sha256');

  for (const file of sourceFiles.sort()) {
    hasher.update(readFileSync(file, { encoding: 'utf-8', flag: 'r' }));
  }

  const hash = hasher.digest('hex').slice(0, 16);

  const compiler = webpack({
    mode: 'production',
    plugins: [
      new webpack.BannerPlugin({
        banner: function () {
          const { repository, name, version } = packageFile;
          let readme: string = readmeContent;

          if (packageDir.length && !readmeContent) {
            const regExp = /^readme\.md$/i;

            for (const object of packageDir) {
              if (regExp.test(object)) {
                readme = readFileSync(object, {
                  encoding: 'utf-8',
                  flag: 'r',
                });

                break;
              }
            }
          }

          if (!repository) {
            console.warn(
              chalk.yellow(
                'Please define "repository" field in you package.json file',
              ),
            );
          }

          let helperRepository = '';

          if (typeof helperPackage.repository === 'string') {
            helperRepository = helperPackage.repository;
          } else if (typeof helperPackage.repository === 'object') {
            helperRepository =
              helperPackage.repository.url?.slice(
                helperPackage.repository.url?.indexOf('http'),
              ) ?? '';
          }

          return `***** DO NOT EDIT! THIS CODE IS GENERATED BY THE PACKAGE ${
            helperPackage.name
          } (${helperRepository}) *****

Please, go to code sources and add your changes!

Code sources:
  Package name: ${name}
  Package version: ${version}
  Package repository: ${repository ? repository : 'Not defined'}
  Build command: npm run ${process.env.npm_lifecycle_event}
  Built at: ${new Date().toISOString()}
  Script source hash: ${hash}
  Checksum: 0000000000000000
  ${V7 ? 'Compatibility: v7 ONLY\n' : ''}

  ***** ----- * PARAMS BASE64 * ----- *****
  ${paramsBase64String}
  ***** ----- * END PARAMS BASE64 * ----- *****

***** ----- ----- ----- ----- ----- ----- *****${paramsDescription}${readme ? `\n\n***** README.md *****\n\n${readme}\n***** --------- *****` : ''}`;
        },
      }),
      new webpack.NormalModuleReplacementPlugin(/-TARGET_EXTENSION$/, function (
        resource,
      ) {
        resource.request = resource.request.replace(
          /-TARGET_EXTENSION/,
          `-${V7 ? 'v7' : 'v6'}`,
        );

        if (resource.createData) {
          resource.createData.request = resource.request;
        }
      }),
    ],
    optimization: { minimize: false },
    target: ['web', !V7 ? 'es5' : 'es2023'],
    entry: filename,
    output: {
      path: DIST_DIR,
      filename: `${path.parse(filename).name}.js`,
    },
    stats: 'errors-warnings',
    module: {
      rules: [
        {
          test: /\.tsx?$/,
          exclude: /node_modules/,
          use: {
            loader: 'babel-loader',
            options: {
              presets: [
                ['@babel/preset-env', presetEnv],
                '@babel/preset-typescript',
              ],
            },
          },
        },
        {
          test: /\.[mc]?js$/,
          exclude: {
            not: [/node_modules/],
          },
          use: {
            loader: 'babel-loader',
            options: {
              presets: [['@babel/preset-env', presetEnv]],
            },
          },
        },
      ],
    },
    resolve: {
      extensions: ['.tsx', '.ts', '.js', '.mjs', '.cjs'],
    },
  } satisfies Configuration);

  const outputBasename = `${path.parse(filename).name}.js`;
  // Placeholder replaced with build hash after compile. To verify content: replace
  // "Checksum: <hex>" with "Checksum: 0000000000000000", then
  // hash the file; result should equal the stored build hash.
  const BUILD_HASH_PLACEHOLDER = '0000000000000000';

  await new Promise<{
    err: Parameters<Parameters<typeof compiler.run>[0]>[0];
    stats: Parameters<Parameters<typeof compiler.run>[0]>[1];
  }>((resolve) => {
    compiler.run((err, stats) => resolve({ err, stats }));
  }).then(({ err, stats }) => {
    if (err || stats?.hasErrors()) {
      if (err) {
        console.error(err);
      } else {
        console.log(stats?.toString({ colors: true }));
      }

      console.log(chalk.red('Code compiled with error'));
    } else {
      console.log(stats?.toString({ colors: true }));

      const outputPath = path.join(DIST_DIR, outputBasename);
      const content = readFileSync(outputPath, { encoding: 'utf-8' });
      const contentWithoutTabs = content.replace(/\t/g, '  ');
      
      // Normalize line endings to LF (matches validation code checksum2)
      const contentNormalized = contentWithoutTabs.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
      
      // Calculate hash from normalized content (matches Get-FileHash when normalized to LF)
      // Use Buffer.from() to match TextEncoder.encode() behavior in validation code
      const contentWithPlaceholder = contentNormalized;
      const data = Buffer.from(contentWithPlaceholder, 'utf-8');
      const buildHasher = nodeCrypto.createHash('sha256');

      buildHasher.update(data);
      
      const buildHash = buildHasher.digest('hex').slice(0, 16);
      
      // Replace placeholder with actual hash
      const contentWithHash = contentNormalized.replace(
        `Checksum: ${BUILD_HASH_PLACEHOLDER}`,
        `Checksum: ${buildHash}`,
      );

      console.log(chalk.green(`Checksum: ${buildHash}`));
      writeFileSync(outputPath, contentWithHash, { encoding: 'utf-8' });

      console.log(chalk.green('Done'));
    }
  });
})();
